function [dist, path] = aStar(graph, emissions, startNode, endNode, locations, maxCarbon) % functia A* in functie de costuri si emisii de carbon

    N = size(graph, 1); % Numar total de aeroporturi
    
    %Initializare
    dist = inf(1, N);
    dist(startNode) = 0;
    prev = -ones(1, N);
    fScore = inf(1, N);
    fScore(startNode) = euristic(startNode, endNode, locations);
    openSet = startNode;

      while ~isempty(openSet)
        % a
        [~, idx] = min(fScore(openSet));
        current = openSet(idx);

        % Dacă am ajuns la destinație, reconstruim calea
        if current == endNode
            path = [];
            while current ~= -1
                path = [current path];
                current = prev(current);
            end
            return;
        end
        
        % Eliminăm nodul curent din openSet
        openSet(idx) = [];

        % Parcurgem vecinii nodului curent
        for neighbor = 1:N
            if graph(current, neighbor) > 0 && emissions(current, neighbor) <= maxCarbon
                tentative_gScore = dist(current) + graph(current, neighbor);

                if tentative_gScore < dist(neighbor)
                    prev(neighbor) = current;
                    dist(neighbor) = tentative_gScore;
                    fScore(neighbor) = dist(neighbor) + euristic(neighbor, endNode, locations);

                    if ~ismember(neighbor, openSet)
                        openSet = [openSet, neighbor];
                    end
                end
            end
        end
    end
    
    % Dacă nu există drum
    path = [];
end